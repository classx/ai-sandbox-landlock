# ai-sandbox-landlock — план проекта

## 1. Цели и контекст

- Ограничить доступ IDE/LLM (VSCode, Copilot‑backend, локальные LLM) к файловой системе с помощью Linux Landlock LSM.
- Сделать это **без root** и без eBPF: обычный пользователь запускает лаунчер, который сам на себя вешает Landlock‑ограничения и стартует целевую команду.
- Описывать политику доступа декларативно в YAML‑профилях (наподобие `ai-sandbox-landlock.yaml`).
- Поддержать несколько профилей ("vscode-copilot", "copilot-backend", "minimal" и т.п.) и гибкую настройку прав на каталоги.

## 2. Анализ требований (по tz.md)

- Используем Landlock как LSM:
  - Ядро ≥ 5.13, включён `CONFIG_SECURITY_LANDLOCK`, опция `lsm=...landlock...` в cmdline.
  - Landlock только **ужесточает** права, не может дать больше, чем DAC/SELinux/AppArmor.
- Модель использования:
  - Rust‑лаунчер создаёт ruleset с нужными типами доступа (`handled_access_fs`).
  - Добавляет правила `PATH_BENEATH` для корней проектов и системных каталогов.
  - Вызывает `landlock_restrict_self`, после чего выполняет `exec`/`Command` целевой программы (VSCode, Copilot‑сервер и т.п.).
  - Все дочерние процессы наследуют ограничения.
- Конфигурация:
  - YAML‑файл с версиями, профилями, `access_roots`, `control_access`, описанием запускаемой команды и опциями (`dry_run`, `log_level`).
  - Для каждого root свои права (`read_file`, `write_file`, `execute`, `remove_file`, ...).
- Ограничения и особенности:
  - Права фиксируются на момент `restrict_self`; уже открытые FD сохраняют возможности.
  - Landlock не меняет видимость деревьев, а только запрещает операции.
  - Возможна комбинация с mount‑namespace для скрытия лишних частей ФС.

Вывод: основная ценность проекта — удобный CLI/конфиг вокруг Landlock с безопасными и понятными профилями под рабочие сценарии (IDE, LLM‑серверы и т.п.).

## 3. Архитектура решения (высокий уровень)

- **Бинарь `ai-sandbox-landlock` (Rust):**
  - CLI‑парсер аргументов (`--config`, `--profile`, `--dry-run`, `--verbose`, `--` и т.п.).
  - Модуль работы с конфигом (YAML → внутренние структуры).
  - Модуль маппинга прав (YAML → `landlock` crate: `Ruleset`, `PathBeneath`, `Access` и т.п.).
  - Модуль применения ограничений (`ruleset.restrict_self()` + обработка версий ABI).
  - Модуль запуска целевой команды (working_dir, env, передача сигналов, код возврата).
  - Логирование и отладка (лог‑уровни, `dry_run` режим, печать итогового ruleset’а).

- **Конфигурационный файл (YAML‑схема):**
  - `version` схемы.
  - `profiles.<name>.access_roots.<group>.paths` + `permissions`.
  - `profiles.<name>.control_access` — какие типы доступа вообще контролируем.
  - `profiles.<name>.command` — `binary`, `args`, `working_dir`, `env`.
  - Доп. опции профиля (`log_level`, `dry_run` по умолчанию, поведение при отсутствии Landlock).

- **Зависимости:**
  - `landlock` crate для работы с Landlock ABI.
  - `serde`, `serde_yaml` для конфигов.
  - `clap` или `argh` для CLI.
  - `anyhow`/`thiserror` для ошибок.

## 4. Этапы реализации

### Этап 0. Подготовка окружения и предпосылки

**Цель:** убедиться, что проект можно собрать и запустить на целевых системах.

- Проверить, что целевая система:
  - Ядро ≥ 5.13, поддерживает Landlock (`grep LANDLOCK /boot/config-*` или `/proc/config.gz`).
  - В cmdline ядра присутствует `landlock` в параметре `lsm` (или используется конфигурация по умолчанию с Landlock).
- Определить минимально поддерживаемую версию ABI Landlock (через `landlock` crate или пробный вызов `landlock_create_ruleset`).
- Спланировать поддержку сценария "нет Landlock":
  - Флаг `--require-landlock` (падать с ошибкой при отсутствии).
  - По умолчанию: логировать предупреждение и запускать без песочницы, либо наоборот.

**Результат:** документированная матрица поддержки (дистрибутивы, версии ядра, поведение при отсутствии Landlock).

---

### Этап 1. Базовый Rust‑лаунчер с жёстко заданными путями

**Цель:** рабочий минимальный прототип без YAML, который:
- проверяет наличие Landlock;
- ограничивает доступ к одному каталогу проекта;
- запускает указанную команду.

**Шаги:**

- Инициализировать Rust‑crate:
  - `cargo init --bin ai-sandbox-landlock`.
  - Добавить зависимости: `landlock`, `clap`, `anyhow`, `log`, `env_logger`.
- Реализовать простой CLI:
  - Аргументы: `--root <PATH> [--read-only] -- <COMMAND> [ARGS...]`.
- Логика Landlock:
  - Проверить совместимость Landlock (`Ruleset::default().compatibility()` или эквивалент).
  - Сформировать ruleset с базовыми правами (`read_file`, `read_dir`, `execute`, опционально `write_file`).
  - Добавить одно правило `PathBeneath` для `--root`.
  - Вызвать `restrict_self()`.
- Запуск команды:
  - Использовать `std::process::Command` для запуска целевого процесса.
  - Пробросить код возврата и сигналы по возможности.

**Артефакты:**
- Бинарь `ai-sandbox-landlock` с минимальной функциональностью.
- Документация к прототипу (README или раздел в project.md).

**Критерии готовности:**
- Можно запустить: `ai-sandbox-landlock --root ~/dev/myproj -- code .` и убедиться, что доступ вне `~/dev/myproj` запрещён.

---

### Этап 2. Введение YAML‑конфига и профилей

**Цель:** вынести политику доступа в YAML, поддержать несколько профилей и групп корней.

**Шаги:**

- Описать Rust‑структуры под YAML (serde):
  - `Config { version: u32, profiles: HashMap<String, Profile> }`.
  - `Profile { description, access_roots, control_access, command, log_level, dry_run? }`.
  - `AccessRoots { <group_name>: AccessRootGroup }`.
  - `AccessRootGroup { paths: Vec<String>, permissions: Permissions }`.
  - `Permissions { read_file, read_dir, execute, write_file, remove_file, remove_dir, truncate, ... }`.
  - `ControlAccess { read_file, read_dir, execute, write_file, remove_file, remove_dir, truncate, ... }`.
  - `CommandSpec { binary, args, working_dir, env }`.
- Реализовать загрузку и валидацию конфига:
  - Чтение файла по `--config`.
  - Валидация `version` (напр. поддерживается только 1).
  - Проверка наличия выбранного `--profile`.
  - Валидация путей (непустые, без дубликатов, допустимое количество).
- Поддержать подстановку `~` и относительных путей (приведение к абсолютным):
  - `~` → `$HOME`.
  - `~/dev` и относительные от `working_dir`.

**Артефакты:**
- Реализованный парсер YAML с понятными сообщениями об ошибках.
- Пример конфига (на основе фрагмента из tz.md) в `examples/ai-sandbox-landlock.yaml`.

**Критерии готовности:**
- Запуск `ai-sandbox-landlock --config ai-sandbox-landlock.yaml --profile vscode-copilot` использует настройки из YAML, а не из жёстко заданных значений.

---

### Этап 3. Маппинг YAML‑прав на Landlock (handled_access_fs и PathBeneath)

**Цель:** корректно и предсказуемо переводить YAML‑права в Landlock‑битмаски с учётом версий ABI.

**Шаги:**

- Определить таблицу соответствия:
  - `control_access.*` → `handled_access_fs` (набор `AccessFs` флагов ruleset’а).
  - `permissions.*` для конкретного root → `allowed_access` в `PathBeneath`.
- Учесть версионирование ABI:
  - Определить поддерживаемый набор флагов через `landlock` crate (или через обнаружение ABI‑версии).
  - Игнорировать/логировать те флаги, которые не поддерживаются текущим ABI (например, `remove_dir` на старых ядрах).
- Реализовать генерацию ruleset’а:
  - Создать `Ruleset` с `handled_access_fs` из `control_access`.
  - Для каждого `access_roots.<group>.paths`:
    - Открыть путь через `O_PATH | O_CLOEXEC`.
    - Создать правило `PathBeneath` с `allowed_access` из `permissions`.
    - Добавить правило в ruleset.
- Обработка ошибок:
  - Невозможность открыть root → ошибка профиля.
  - Пустой ruleset (ни одного поддерживаемого бита) → ошибка конфигурации.

**Артефакты:**
- Функции `build_ruleset(profile: &Profile) -> Result<Ruleset, Error>` и вспомогательные мапперы.

**Критерии готовности:**
- Юнит‑тесты на маппинг YAML‑прав → внутренние Landlock‑флаги.
- Возможность включать/выключать отдельные типы операций (например, только `read_*`).

---

### Этап 4. Запуск команд по профилю и UX CLI

**Цель:** сделать удобный CLI‑интерфейс и надёжный запуск целевых команд внутри песочницы.

**Шаги:**

- CLI‑контракт:
  - Режим 1: `--config ... --profile ...` (команда берётся из профиля `command`).
  - Режим 2: `--config ... --profile ... -- <command> [args...]` (override команды профиля).
  - Флаги управления: `--dry-run`, `--require-landlock`, `--log-level`, `--no-color`, `--print-config`, `--print-ruleset` (по мере необходимости).
- Поддержка `working_dir` и `env`:
  - Для запуска использовать `Command::new(binary)` с `current_dir` и `envs` из `command`.
  - Придумать стратегию мерджа env: дополнять текущий env или задавать жёстко.
- Поведение при отсутствии Landlock:
  - Вариант по умолчанию (определить в спецификации проекта):
    - либо запуск без ограничений с жирным WARNING;
    - либо отказ от запуска без `--allow-without-landlock`.
- Обработка завершения процесса:
  - Пробросить код возврата.
  - Корректно обработать случаи, когда команда не найдена.

**Артефакты:**
- CLI с понятной справкой (`--help`).
- Реальный сценарий запуска VSCode/Copilot из профиля.

**Критерии готовности:**
- Удобный человекочитаемый интерфейс, документация в README, покрывающая основные сценарии.

---

### Этап 5. Логирование, отладка и dry‑run

**Цель:** облегчить диагностику проблем с конфигом и Landlock‑правами.

**Шаги:**

- Ввести уровни логов (`error`, `warn`, `info`, `debug`, `trace`).
- Реализовать режим `dry_run` (флаг CLI или опция профиля):
  - Строить ruleset и правила, но **не** вызывать `restrict_self()` и **не** запускать команду.
  - Печатать:
    - нормализованные пути;
    - какие права на какие корни будут применены;
    - какие биты игнорированы из‑за ограничений ABI.
- Опция `--print-ruleset`:
  - Вывод логического представления: список `handled_access_fs` и `PathBeneath` правил (без низкоуровневых FD).

**Артефакты:**
- Лог‑формат (человеческий, возможно с JSON‑опцией в будущем).

**Критерии готовности:**
- Пользователь может запустить `--dry-run` и понять, почему тот или иной доступ блокируется/разрешается.

---

### Этап 6. Тестирование (юнит + интеграционные сценарии)

**Цель:** убедиться в корректности маппинга и минимизировать регрессии.

**Шаги:**

- Юнит‑тесты:
  - Парсинг YAML → структуры.
  - Маппинг `control_access` и `permissions` → Landlock‑флаги (без реального ядра).
  - Нормализация путей и подстановка `~`.
- Интеграционные тесты (на окружении с Landlock):
  - Сценарий "minimal": только чтение одного проекта.
  - Сценарий "vscode-copilot": проект + системные каталоги с R/O.
  - Проверка, что чтение файла вне `access_roots` даёт `EACCES`/`EPERM`.
  - Проверка поведения при отсутствии Landlock (на тестовом контейнере/ядре).
- При необходимости — простые shell‑скрипты для ручного прогона сценариев.

**Критерии готовности:**
- Базовый тестовый набор проходит на целевой платформе.
- Все найденные критические баги маппинга/логики исправлены.

---

### Этап 7. Безопасность и углы

**Цель:** проанализировать и задокументировать поведение в сложных случаях.

**Шаги:**

– Симлинки:
  - Разрешение симлинков происходит в момент операции; если симлинк приводит за предел разрешённых деревьев, операция блокируется (например, `open()` файла через симлинк вне `access_roots`).
  - Рекомендация: указывать реальные каталоги, избегать симлинков в путях профиля; для кэшей использовать отдельные директории.
– Bind‑mount:
  - Landlock ограничивает операции согласно иерархии в файловой системе; bind‑mount может "притянуть" внешние деревья в разрешённый путь.
  - Рекомендация: сочетать Landlock с mount‑namespace (скрыть лишние части ФС), либо не использовать bind‑mount внутри разрешённых корней.
– Открытые дескрипторы (FD):
  - Landlock фиксирует права на момент `restrict_self`; уже открытые FD сохраняют возможности.
  - Лаунчер не должен открывать широкие FD до `restrict_self`; текущая реализация открывает только конфиг и служебные файлы, которые закрываются до применения ограничений.
– Наследование и взаимодействие с LSM/DAC:
  - Ограничения наследуются дочерними процессами.
  - Landlock только ужесточает доступ: действует поверх DAC/SELinux/AppArmor и не предоставляет дополнительных привилегий.
– Ограничения ABI:
  - Набор поддерживаемых прав зависит от версии ABI ядра; лаунчер динамически определяет доступные биты и в `--dry-run`/`--print-ruleset` помечает игнорируемые.
– Пользовательский UX:
  - Понятные сообщения об ошибках при доступе, невозможности создать ruleset, ошибке ABI.

Смотри подробности и рекомендации в [private/projects/ai-sandbox-landlock/SECURITY.md](private/projects/ai-sandbox-landlock/SECURITY.md).

**Критерии готовности:**
– Есть раздел "Безопасность и ограничения" с конкретными сценариями и рекомендациями; `--dry-run` демонстрирует игнорируемые права.

---

### Этап 8. Документация и упаковка

**Цель:** сделать проект удобным для установки и использования.

**Шаги:**

- Документация:
  - Обновить/создать README с:
    - кратким описанием проекта;
    - примерами установки;
    - примерами конфигов (`vscode-copilot`, `copilot-backend`, `minimal`);
    - FAQ по ошибкам и типичным сценариям.
  - Описать YAML‑схему (типы, значения по умолчанию, поддерживаемые флаги).
- Упаковка:
  - Настроить `cargo install` сценарий.
  - Подготовить инструкции для интеграции с:
    - VSCode (alias/скрипт для запуска `code` через `ai-sandbox-landlock`);
    - Copilot‑backend / LLM‑сервер (обёртки в systemd‑unit, если нужно).

**Критерии готовности:**
- Пользователь, незнакомый с внутренностями проекта, может по README установить и запустить один из примеров профиля.

---

### Этап 9. Дальнейшее развитие (после MVP)

**Идеи для следующих итераций:**

- Поддержка комбинации с namespace‑песочницей (mount/user/ns):
  - Опционально запускать команду в отдельном mount‑namespace с ограниченным набором FS.
  - Landlock сверху как "LSM‑стопер".
- Дополнительные типы ресурсов:
  - Базовая сетевые ограничения (через отдельные механизмы, не Landlock).
  - Ограничения на IPC/память (через cgroups/namespace).
- Динамическая генерация профилей:
  - Автоматическое создание профиля под конкретный проект (например, по корню git‑репозитория).
- Интеграция с другими инструментами разработчика.

## 5. Итог

Данный план разбивает реализацию `ai-sandbox-landlock` на последовательные этапы: от минимального лаунчера с одним каталогом до полноценной системы профилей с YAML‑конфигами, отладкой и документацией. Каждый этап имеет ясные цели, артефакты и критерии готовности, что позволяет двигаться итеративно и при этом рано получить рабочий MVP для ограничения доступа IDE/LLM к проекту.
